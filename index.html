<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - performance</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		background:#fff;
		padding:0;
		margin:0;
		font-weight: bold;

		overflow:hidden;
		text-align: center;
	}
	a { color: white }

	#info { position: absolute; top: 10px; width: 100%; color: yellow;}
	</style>
</head>
<body>
	<div id="info">
		<p>
			Cube Map Texture by <a href="http://www.humus.name/index.php?page=Textures">Humus</a>
		</p>
		<p>
			Check Out Source code on <a href="https://github.com/tiansijie/WebGLpbr">Sijie's Github</a>
		</p>
	</div>

	<div id="container" style="width: 100%; height: 100%;"></div>
	<script src="./threejs/build/three.js"></script>
	<script src="./threejs/controls/OrbitControls.js"></script>
	<script type="text/javascript" src="./dat.gui.min.js"></script>
	<script src="./stats.min.js"></script>

	<script id="vertexShader" type="x-shader/x-vertex">

	precision mediump float;
	precision mediump int;

	varying vec3 vViewPosition;
	varying vec3 vNormal;
	varying vec3 wNormal;

	void main()	{


		vec4 mvPosition = modelViewMatrix * vec4(position,1.0);
		vViewPosition = (mvPosition).xyz / mvPosition.w;
		vNormal = normalMatrix * normal;
		wNormal = ( vec4(normal, 1.0) ).xyz;
		//vUv = uv;
		gl_Position = projectionMatrix * mvPosition;
	}

	</script>

	<script id="fragmentShader_param" type="x-shader/x-fragment">

	precision mediump float;
	precision mediump int;

	uniform vec3 u_lightColor;
	uniform vec3 u_lightDir;
	uniform vec3 u_lightPos;
	uniform vec3 u_diffuseColor;
	uniform float u_roughness;
	uniform float u_fresnel;
	uniform float u_alpha;
	uniform vec3 u_ambientColor;
	uniform samplerCube u_tCube;
	uniform float u_time;


	varying vec3 vViewPosition;
	varying vec3 vNormal;
	varying vec3 wNormal;


	#define M_PI 3.1415926535897932384626433832795

	float dotClamped(vec3 a, vec3 b) {
		return max(dot(a,b), 0.0);
	}

	float F(float f0, vec3 l, vec3 h) {
		float LoH = dot(l,h);
		float powTerm = (-5.55473 * LoH - 6.98316) * LoH;
		return f0 + (1.0 - f0) * pow(2.0, powTerm);
		//return f0 + (1.0-f0) * pow(1.0-dot(l,h),5.0);
	}

	</script>


	<script id="NDFBlinnPhong" type="x-shader/x-fragment">
	float N(float a, vec3 n, vec3 h, float NoH) {
		float a2 = a*a;
		float powTerm = 2.0 / a2 - 2.0;
		return (1.0 / (4.0 * a2)) * (pow(NoH, powTerm));
	}
	</script>

	<script id="NDFBeckmann" type="x-shader/x-fragment">
	float N(float a, vec3 n, vec3 h, float NoH) {
		float a2 = a*a;
		float NoH2 = pow(NoH, 2.0);
		return (1.0 / (4.0 * a2 * pow(NoH, 4.0))) * exp((NoH2 - 1.0) / (a2 * NoH2));
	}
	</script>

	<script id="NDFGGX" type="x-shader/x-fragment">
	float N(float a, vec3 n, vec3 h, float NoH) {
		float a2 = a*a;
		return a2 / (4.0 * pow(pow(NoH, 2.0) * (a2 - 1.0) + 1.0, 2.0));
	}
	</script>

	<script id="GImplicit" type="x-shader/x-fragment">
	float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
		return 1.0;
	}
	</script>


	<script id="GCookTorrance" type="x-shader/x-fragment">
	float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
		float VdotH = max(dot(v,h), 0.0);
		float NdotH = max(dot(n,h), 0.0);
		float minV = 2.0 * NdotH * min(NoV, NoL) / VdotH;
		return min(1.0, minV);
	}
	</script>


	<script id="GKelemen" type="x-shader/x-fragment">
	float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
		return (1.0) / pow(dot(v,h), 2.0);
	}
	</script>


	<script id="GBeckmann" type="x-shader/x-fragment">

	float GBeckmannHelper(float a, float NoT) {
		return NoT / (a * sqrt(1.0 - pow(NoT, 2.0)));
	}

	float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
		float c1 = GBeckmannHelper(a, NoV);
		float c2 = GBeckmannHelper(a, NoL);

		float c12 = c1*c1;
		float c22 = c2*c2;
		float GV, GL;

		if(c1 < 1.6) {
			GV = (3.535 * c1 + 2.181 * c12) / (1.0 + 2.276*c1 + 2.577*c12);
		}
		else {
			GV = 1.0;
		}

		if(c2 < 1.6) {
			GL = (3.535 * c2 + 2.181 * c22) / (1.0 + 2.276*c2 + 2.577*c22);
		}
		else {
			GL = 1.0;
		}

		return GL*GV;
	}
	</script>


	<script id="GSchlick_Beckmann" type="x-shader/x-fragment">
	float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
		float k = a * sqrt(2.0/M_PI);
		float GV = 1.0 / (NoV * (1.0-k) + k);
		float GL = 1.0 / (NoL * (1.0-k) + k);
		return GV*GL;
	}
	</script>


	<script id="fragmentShader_main" type="x-shader/x-fragment">
	float random(vec3 scale, float seed) {
		return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
	}

	float rnd(vec2 uv) {
    return fract(sin(dot(uv, vec2(12.9898, 78.233) * 2.0)) * 43758.5453);
	}

	float saturate(float x) {
    return clamp(x, 0.0, 1.0);
	}

	vec2 RandomSamples(float seed) {
		float u = random(vec3(12.9898, 78.233, 151.7182), seed);
		float v = random(vec3(63.7264, 10.873, 623.6736), seed);
		return vec2(u, v);
	}

	vec3 ImportanceSampleGGX( vec2 Xi, float Roughness, vec3 N ) {
		float a = Roughness * Roughness;
		float Phi = 2.0 * M_PI * Xi.x;
		float CosTheta = sqrt( (1.0 - Xi.y) / ( 1.0 + (a*a - 1.0) * Xi.y ) );
		float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );
		vec3 H;
		H.x = SinTheta * cos( Phi );
		H.y = SinTheta * sin( Phi );
		H.z = CosTheta;

		vec3 UpVector = abs(N.z) < 0.999? vec3(0.0,0.0,1.0) : vec3(1.0, 0.0, 0.0);
		vec3 TangentX = normalize( cross(UpVector, N) );
		vec3 TangentY = cross(N, TangentX);
		return TangentX * H.x + TangentY * H.y + N * H.z;
	}


	vec3 SpecularIBL( float Roughness, vec3 NL, vec3 V, float fresnel )
	{
		//L: viewLightDir
		//H: halfVector
		//V: viewNormal
		//V: viewDir

		vec3 SpecularLighting = vec3(0.0);
		const int NumSamples = 64;
		for( int i = 0; i < NumSamples; i++ )
		{
			vec2 Xi = RandomSamples( u_time + float(i) );
			vec3 H = ImportanceSampleGGX( Xi, Roughness, NL );
			vec3 L = 2.0 * dot( V, H ) * H - V;
			float NoV = max( dot( NL, V ), 0.0 );
			float NoL = max( dot( NL, L ), 0.0 );
			float NoH = max( dot( NL, H ), 0.0 );
			float VoH = max( dot( V, H ), 0.0 );


			if( NoL > 0.0 )
			{
				vec3 SampleColor = textureCube (u_tCube, L).xyz;

				float fresnel_fn = F(fresnel, L, H);
				/*Put M_PI/4.0 in to NDF functions*/
				float ndf_fn = N(Roughness, NL, H, NoH);
				/*Put /(NoL*NoV) in G funtion*/
				float g_fn = G(Roughness, L, V, H, NL, NoL, NoV);

				SpecularLighting += fresnel_fn * ndf_fn * g_fn * SampleColor;
			}
		}
		return SpecularLighting / float(NumSamples);
	}


	vec3 PrefilterEnvMap( float Roughness, vec3 R )
	{
		vec3 N = R;
		vec3 V = R;
		vec3 PrefilteredColor = vec3(0.0);
		float TotalWeight = 0.0;
		const int NumSamples = 64;

		for( int i = 0; i < NumSamples; i++ )
		{
			vec2 Xi = RandomSamples( u_time + float(i) );
			vec3 H = ImportanceSampleGGX( Xi, Roughness, N );
			vec3 L = 2.0 * dot( V, H ) * H - V;

			float NoL = saturate( dot( N, L ) );
			if( NoL > 0.0 )
			{
				PrefilteredColor += textureCube (u_tCube, L).xyz * NoL;
				TotalWeight += NoL;
			}
		}

		return PrefilteredColor * (1.0 /  TotalWeight ) ;
	}

	float G_Smith(float Roughness, float NoV, float NoL) {
		Roughness = pow((Roughness + 1.0), 2.0) / 8.0;
		float G1 = NoV / (NoV * (1.0 - Roughness) + Roughness);
		float G2 = NoL / (NoL * (1.0 - Roughness) + Roughness);

		return G1*G2;
	}


	vec2 IntegrateBRDF( float Roughness, float NoV)
	{
		vec3 V;
		V.x = sqrt( 1.0 - NoV * NoV ); // sin
		V.y = 0.0;
		V.z = NoV; // cos
		float A = 0.0;
		float B = 0.0;
		const int NumSamples = 64;
		for( int i = 0; i < NumSamples; i++ )
		{
			vec2 Xi = RandomSamples( u_time + float(i) );
			vec3 H = ImportanceSampleGGX( Xi, Roughness, V );
			vec3 L = 2.0 * dot( V, H ) * H - V;
			float NoL = saturate( L.z );
			float NoH = saturate( H.z );
			float VoH = saturate( dot( V, H ) );

			if( NoL > 0.0 )
			{
				float G = G_Smith( Roughness, NoV, NoL );
				if(G > 0.0) {
					float G_Vis = G * VoH / (NoH * NoV);
					float Fc = pow( 1.0 - VoH, 5.0 );
					A += (1.0 - Fc) * G_Vis;
					B += Fc * G_Vis;
				}
			}

		}
		return vec2( A, B ) / float(NumSamples);
	}


	vec3 ApproximateSpecularIBL( float fresnel , float Roughness, vec3 N, vec3 V ) {
		float NoV = saturate( dot( N, V ) );
		vec3 R = 2.0 *  dot( N, V ) * N - V;
		vec3 PrefilteredColor = PrefilterEnvMap( Roughness, R );
		vec2 EnvBRDF = IntegrateBRDF( Roughness, NoV );
		return PrefilteredColor * ( fresnel * EnvBRDF.x + EnvBRDF.y );
	}


	vec3 dirDiffuse = vec3(0.0);
	vec3 dirSpecular = vec3(0.0);

	void calDirLight(vec3 lDir, vec3 normal, vec3 diffuse, vec3 specular) {

		vec3 dirLightColor = vec3(1.0);

		vec4 lDirection = viewMatrix * vec4( lDir, 0.0 );
		vec3 dirVector = normalize( lDirection.xyz );

		float dirDiffuseWeight = max(dot( normal, dirVector ), 0.0);

		dirDiffuse += diffuse * dirLightColor * dirDiffuseWeight * 0.5;

		vec3 dirHalfVector = normalize( dirVector + vViewPosition );
		float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );
		float dirSpecularWeight = 0.5 * max( pow( dirDotNormalHalf, 0.0 ), 0.0 );

		float specularNormalization = ( 0.0 + 2.0 ) / 8.0;

		vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );
		dirSpecular += schlick * dirLightColor * dirSpecularWeight * dirDiffuseWeight * specularNormalization;

	}

	float lerp (float x, float y, float a) {
		return x * (1.0-a) + y * a;
	}

	vec3 F_Schlick (vec3 f0, float f90, float u )
	{
		return f0 + vec3(f90 - f0) * pow (1.0 - u , 5.0);
	}

	float Fr_DisneyDiffuse ( float NdotV , float NdotL , float LdotH , float linearRoughness ) {
		float energyBias = lerp (0.0 , 0.5 , linearRoughness );
		float energyFactor = lerp (1.0 , 1.0 / 1.51 , linearRoughness );
		float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness ;
		vec3 f0 = vec3 (1.0, 1.0, 1.0);
		float lightScatter = F_Schlick ( f0 , fd90 , NdotL ) .r;
		float viewScatter = F_Schlick (f0 , fd90 , NdotV ).r;
		return lightScatter * viewScatter * energyFactor ;
	}


	void main()	{
		//		viewMatrix
		//		cameraPosition

		// vec4 viewLightPos = viewMatrix * vec4( u_lightPos, 1.0 );
		// vec3 viewLightDir = viewLightPos.xyz - vViewPosition.xyz;
		// viewLightDir = normalize(viewLightDir);

		vec3 viewNormal = normalize(vNormal.xyz);
		vec3 viewDir = normalize(-vViewPosition);
		vec3 worldNormal = normalize(wNormal);

		// vec3 halfVec = normalize(viewDir + viewLightDir);
		// float NoV = max( dot( viewNormal, viewDir ), 0.0 ) + 1e-5;
		// float NoL = max( dot( viewNormal, viewLightDir ), 0.0 );
		// float LoH = max( dot( viewLightDir, halfVec ), 0.0 );
		// float NoH = max( dot( viewNormal, halfVec), 0.0);

		//float diffuse = Fr_DisneyDiffuse(NoV, NoL, LoH, pow(u_roughness + 1.0, 2.0)/8.0) / M_PI ;

		vec3 specularIBL = ApproximateSpecularIBL(u_fresnel, u_roughness, viewNormal, viewDir);

		gl_FragColor = vec4( specularIBL * 0.4 + u_ambientColor, 1.0);
	}
	</script>
	<script type="text/javascript" src="./main2.js"></script>

</body>
</html>
