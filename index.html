<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - performance</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				background:#fff;
				padding:0;
				margin:0;
				font-weight: bold;

				overflow:hidden;
				text-align: center;
			}
			a { color: white }

			#info { position: absolute; top: 10px; width: 100%; color: yellow;}
		</style>
	</head>
	<body>
		<div id="info">
			<p>
				Cube Map Texture by <a href="http://www.humus.name/index.php?page=Textures">Humus</a>
			</p>
			<p>
				Check Out Source code on <a href="https://github.com/tiansijie/WebGLpbr">Sijie's Github</a>
			</p>
		</div>

		<div id="container" style="width: 100%; height: 100%;"></div>
		<script src="./threejs/build/three.js"></script>
		<script src="./threejs/controls/OrbitControls.js"></script>
		<script type="text/javascript" src="./dat.gui.min.js"></script>
		<script src="./stats.min.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			precision mediump float;
			precision mediump int;

			varying vec3 vViewPosition;
			varying vec3 vNormal;
			//varying vec2 vUv;

			void main()	{
				vec4 mvPosition = modelViewMatrix * vec4(position,1.0);
				vViewPosition = mvPosition.xyz;//(mvPosition).xyz / mvPosition.w;
				vNormal = normalMatrix * normal.xyz;
				//vUv = uv;
				gl_Position = projectionMatrix * mvPosition;
			}

		</script>

		<script id="fragmentShader_param" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform vec3 u_lightColor;
			uniform vec3 u_lightDir;
			uniform vec3 u_lightPos;
			uniform vec3 u_viewPos;
			uniform vec3 u_diffuseColor;
			uniform float u_roughness;
			uniform float u_fresnel;
			uniform float u_alpha;
			uniform vec3 u_ambientColor;
			uniform samplerCube u_tCube;
			uniform float u_time;


			varying vec3 vViewPosition;
			varying vec3 vNormal;
			varying vec2 vUv;


			#define M_PI 3.1415926535897932384626433832795

			float dotClamped(vec3 a, vec3 b) {
				return max(dot(a,b), 0.0);
			}

			float F(float f0, vec3 l, vec3 h) {
				float LoH = dot(l,h);
				float powTerm = (-5.55473 * LoH - 6.98316) * LoH;
				return f0 + (1.0 - f0) * pow(2.0, powTerm);
				//return f0 + (1.0-f0) * pow(1.0-dot(l,h),5.0);
			}

		</script>


		<script id="NDFBlinnPhong" type="x-shader/x-fragment">
			float N(float a, vec3 n, vec3 h, float NoH) {
				float a2 = a*a;
				float powTerm = 2.0 / a2 - 2.0;
				return (1.0 / (4.0 * a2)) * (pow(NoH, powTerm));
			}
		</script>

		<script id="NDFBeckmann" type="x-shader/x-fragment">
			float N(float a, vec3 n, vec3 h, float NoH) {
				float a2 = a*a;
				float NoH2 = pow(NoH, 2.0);
				return (1.0 / (4.0 * a2 * pow(NoH, 4.0))) * exp((NoH2 - 1.0) / (a2 * NoH2));
			}
		</script>

		<script id="NDFGGX" type="x-shader/x-fragment">
			float N(float a, vec3 n, vec3 h, float NoH) {
				float a2 = a*a;
				return a2 / (4.0 * pow(pow(NoH, 2.0) * (a2 - 1.0) + 1.0, 2.0));
			}
		</script>

		<script id="GImplicit" type="x-shader/x-fragment">
			float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
				return 1.0;
			}
		</script>


		<script id="GCookTorrance" type="x-shader/x-fragment">
			float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
				float VdotH = max(dot(v,h), 0.0);
				float NdotH = max(dot(n,h), 0.0);
				float minV = 2.0 * NdotH * min(NoV, NoL) / VdotH;
				return min(1.0, minV);
			}
		</script>


		<script id="GKelemen" type="x-shader/x-fragment">
			float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
				return (1.0) / pow(dot(v,h), 2.0);
			}
		</script>


		<script id="GBeckmann" type="x-shader/x-fragment">

			float GBeckmannHelper(float a, float NoT) {
				return NoT / (a * sqrt(1.0 - pow(NoT, 2.0)));
			}

			float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
				float c1 = GBeckmannHelper(a, NoV);
				float c2 = GBeckmannHelper(a, NoL);

				float c12 = c1*c1;
				float c22 = c2*c2;
				float GV, GL;

				if(c1 < 1.6) {
					GV = (3.535 * c1 + 2.181 * c12) / (1.0 + 2.276*c1 + 2.577*c12);
				}
				else {
					GV = 1.0;
				}

				if(c2 < 1.6) {
					GL = (3.535 * c2 + 2.181 * c22) / (1.0 + 2.276*c2 + 2.577*c22);
				}
				else {
					GL = 1.0;
				}

				return GL*GV;
			}
		</script>


		<script id="GSchlick_Beckmann" type="x-shader/x-fragment">
			float G(float a, vec3 l, vec3 v, vec3 h, vec3 n, float NoL, float NoV) {
				float k = a * sqrt(2.0/M_PI);
				float GV = 1.0 / (NoV * (1.0-k) + k);
				float GL = 1.0 / (NoL * (1.0-k) + k);
				return GV*GL;
			}
		</script>


		<script id="fragmentShader_main" type="x-shader/x-fragment">
			float random(vec3 scale, float seed) {
				return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);
			}

			float lerp (float x, float y, float a) {
				return x * (1.0-a) + y * a;
			}

			vec3 F_Schlick (vec3 f0, float f90, float u )
			{
				return f0 + vec3(f90 - f0) * pow (1.0 - u , 5.0);
			}

			float Fr_DisneyDiffuse ( float NdotV , float NdotL , float LdotH , float linearRoughness )
			{
				float energyBias = lerp (0.0 , 0.5 , linearRoughness );
				float energyFactor = lerp (1.0 , 1.0 / 1.51 , linearRoughness );
			 	float fd90 = energyBias + 2.0 * LdotH * LdotH * linearRoughness ;
			 	vec3 f0 = vec3 (1.0, 1.0, 1.0);
			 	float lightScatter = F_Schlick ( f0 , fd90 , NdotL ) .r;
			 	float viewScatter = F_Schlick (f0 , fd90 , NdotV ).r;

			 	return lightScatter * viewScatter * energyFactor ;
			 }


			float V_SmithGGXCorrelated ( float NdotL , float NdotV , float alphaG )
			{
				 // Original formulation of G_SmithGGX Correlated
				 // lambda_v = ( -1 + sqrt ( alphaG2 * (1 - NdotL2 ) / NdotL2 + 1)) * 0.5 f;
				 // lambda_l = ( -1 + sqrt ( alphaG2 * (1 - NdotV2 ) / NdotV2 + 1)) * 0.5 f;
				 // G_SmithGGXCorrelated = 1 / (1 + lambda_v + lambda_l );
				 // V_SmithGGXCorrelated = G_SmithGGXCorrelated / (4.0 f * NdotL * NdotV );

				 // This is the optimize version
				 float alphaG2 = alphaG * alphaG ;
				 // Caution : the " NdotL *" and " NdotV *" are explicitely inversed , this is not a mistake .
				 float Lambda_GGXV = NdotL * sqrt (( - NdotV * alphaG2 + NdotV ) * NdotV + alphaG2 );
				 float Lambda_GGXL = NdotV * sqrt (( - NdotL * alphaG2 + NdotL ) * NdotL + alphaG2 );

				 return 0.5 / ( Lambda_GGXV + Lambda_GGXL );
			}

			float D_GGX ( float NdotH , float m )
			{
				 // Divide by PI is apply later
				 float m2 = m * m ;
				 float f = ( NdotH * m2 - NdotH ) * NdotH + 1.0;
				 return m2 / (f * f) ;
			 }


			float GSchlick_Beckmann(float a, float NoL, float NoV) {
				float k = a * sqrt(2.0/M_PI);
				float GV = 1.0 / (NoV * (1.0-k) + k);
				float GL = 1.0 / (NoL * (1.0-k) + k);
				return GV*GL;
			}

			vec2 RandomSamples(float seed) {
				float u = random(vec3(12.9898, 78.233, 151.7182), seed);
				float v = random(vec3(63.7264, 10.873, 623.6736), seed);
				return vec2(u, v);
			}

			vec3 ImportanceSampleGGX( vec2 Xi, float Roughness, vec3 N ) {
				float a = Roughness * Roughness;
				float Phi = 2.0 * M_PI * Xi.x;
				float CosTheta = sqrt( (1.0 - Xi.y) / ( 1.0 + (a*a - 1.0) * Xi.y ) );
				float SinTheta = sqrt( 1.0 - CosTheta * CosTheta );
				vec3 H;
				H.x = SinTheta * cos( Phi );
				H.y = SinTheta * sin( Phi );
				H.z = CosTheta;

				vec3 UpVector = abs(N.z) < 0.999? vec3(0.0,0.0,1.0) : vec3(1.0, 0.0, 0.0);
				vec3 TangentX = normalize( cross(UpVector, N) );
				vec3 TangentY = cross(N, TangentX);
				return TangentX * H.x + TangentY * H.y + N * H.z;
			}

			vec2 frac(vec2 u, float diff) {
				float x = u.x + diff;
				float y = u.y + diff;
				x = x - floor(x);
				y = y - floor(y);
				return vec2(x, y);
			}

			vec3 importanceSampleCosDir(vec2 u, vec3 N) {

				vec3 UpVector = abs(N.z) < 0.999? vec3(0.0,0.0,1.0) : vec3(1.0, 0.0, 0.0);
				vec3 TangentX = normalize( cross(UpVector, N) );
				vec3 TangentY = cross(N, TangentX);

				float u1 = u.x;
				float u2 = u.y;

				float r = sqrt(u1);
				float phi = u2 * M_PI * 2.0;

				vec3 L;
				L = vec3(r* cos(phi), r * sin(phi), sqrt(max(0.0, 1.0-u1)));
				L = normalize(TangentX * L.y + TangentY * L.x + N * L.z);
				return L;
			}

			const int NumSamples = 32;
			vec4 integrateDFGOnly( float roughness, vec3 N, vec3 V )
			{
				//L: viewLightDir
				//H: halfVector
				//V: viewNormal
				//V: viewDir

				vec4 acc = vec4(0.0);
				float accWeight = 0.0;
				vec3 SpecularLighting = vec3(0.0);

				for( int i = 0; i < NumSamples; i++ )
				{
					vec2 Xi = RandomSamples( u_time + float(i) );
					vec3 H = ImportanceSampleGGX( Xi, roughness, N );
					vec3 L = 2.0 * dot( V, H ) * H - V;
					float NoV = max( dot( N, V ), 0.0 );
					float NoL = max( dot( N, L ), 0.0 );
					float NoH = max( dot( N, H ), 0.0 );
					float HoL = max( dot( H, L ), 0.0);
					float g = GSchlick_Beckmann(roughness, NoL, NoV);

					// specular GGX DFG preIntegration
					if( NoL > 0.0 && g > 0.0 )
					{
						float GVis = g * HoL / (NoH * NoV);
						float Fc = pow(1.0 - HoL, 5.0);
						acc.x += (1.0-Fc) * GVis;
						acc.y += Fc * GVis;
					}

					Xi = frac(Xi, 0.5);
					float pdf;
					L = importanceSampleCosDir(Xi, N);
					NoL = max( dot(N, L), 0.0);
					pdf = NoL * 1.0/M_PI;
					if(NoL > 0.0) {
						float LoH = max(dot(L, normalize(V + L)), 0.0);
						acc.z += Fr_DisneyDiffuse(NoV, NoL, HoL, sqrt(roughness));
					}
					accWeight += 1.0;
				}
				return acc * (1.0 / accWeight);
			}


			vec3 integrateCubeLDOnly(vec3 V, vec3 N, float roughness) {
				// const int NumSamples = 32;
				// vec3 accBrdf = vec3(0.0);
				// float accBrdfWeight = 0.0;
				// float width = 5.0;
				// for (int i = 0; i < NumSamples; ++i) {
				// 	vec2 Xi = RandomSamples( u_time + float(i) );
				// 	vec3 H = ImportanceSampleGGX( Xi, roughness, N );
				// 	vec3 L = 2.0 * dot( V, H ) * H - V;
				// 	float NoL = dot(N,L);
				// 	if(NoL > 0.0) {
				// 		float NoH = max(dot(N, H), 0.0);
				// 		float LoH = max(dot(L, H), 0.0);
				// 		float pdf = D_GGX(NoH, roughness) / M_PI * NoH / (4.0*LoH);
				// 		float omegaS = 1.0 / (float(NumSamples) * pdf);
				// 		float omegaP = 4.0 * M_PI / (6.0 * width * width);
				// 		float mipLevel = clamp(0.5 * log2(omegaS/omegaP),  0.0 )
				// 	}
				// }
				return vec3(0.0);
			}


			vec3 dirDiffuse = vec3(0.0);
			vec3 dirSpecular = vec3(0.0);

			void calDirLight(vec3 lDir, vec3 normal, vec3 diffuse, vec3 specular) {

				vec3 dirLightColor = vec3(1.0);

				vec4 lDirection = viewMatrix * vec4( lDir, 0.0 );
				vec3 dirVector = normalize( lDirection.xyz );

				float dirDiffuseWeight = max(dot( normal, dirVector ), 0.0);

				dirDiffuse += diffuse * dirLightColor * dirDiffuseWeight * 0.5;

				vec3 dirHalfVector = normalize( dirVector + vViewPosition );
				float dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );
				float dirSpecularWeight = 0.5 * max( pow( dirDotNormalHalf, 0.0 ), 0.0 );

				float specularNormalization = ( 0.0 + 2.0 ) / 8.0;

				vec3 schlick = specular + vec3( 1.0 - specular ) * pow( max( 1.0 - dot( dirVector, dirHalfVector ), 0.0 ), 5.0 );
				dirSpecular += schlick * dirLightColor * dirSpecularWeight * dirDiffuseWeight * specularNormalization;

			}

			float fd90 (float v, float a) {
				return 0.5 + cos(pow(v,2.0)) * a;
			}


			void main()	{

				vec3 viewPosition = (vViewPosition);

				vec4 viewLightPos = viewMatrix * vec4( u_lightPos, 1.0 );
				vec3 viewLightDir = viewLightPos.xyz - viewPosition.xyz;
				viewLightDir = normalize(viewLightDir);

				vec3 viewNormal = normalize(vNormal.xyz);
				vec3 viewDir = normalize(-vViewPosition);
				vec3 halfVec = normalize(viewLightDir + viewDir);
				float fresnel = pow((1.0 - u_fresnel) / (1.0 + u_fresnel), 2.0);

				//float diffuse =  fresnel / M_PI * (1.0 + pow(fd90(1.0-max(dot(lightDir, normal), 0.0), u_alpha), 5.0)) * ( 1.0 + pow(fd90(1.0-max(dot(normal, viewDir), 0.0), u_alpha), 5.0));

				float NoV = max( dot( viewNormal, viewDir ), 0.0 ) + 1e-5;
				float NoL = max( dot( viewNormal, viewLightDir ), 0.0 );
				float LoH = max( dot( viewLightDir, halfVec ), 0.0 );
				float NoH = max( dot( viewNormal, halfVec), 0.0);

				float diffuse = Fr_DisneyDiffuse(NoV, NoL, LoH, pow(u_roughness, 4.0)) / M_PI;


				//float fresnel_fn = F(fresnel, viewLightDir, halfVec);

				vec3 fTerm = F_Schlick(vec3(0.16 * pow(u_fresnel, 2.0)), u_fresnel, LoH);
				// float Vis = V_SmithGGXCorrelated(NoV, NoL, u_roughness);
				// float dTerm = D_GGX(NoH, u_roughness);


				//vec3 specularColor = SpecularIBL(u_alpha, viewNormal, viewDir, fresnel) / M_PI;
				//vec3 specularColor = (fTerm * Vis * dTerm) / M_PI;//vec3(1.0);
				vec3 DFGTerm = integrateDFGOnly(u_roughness, viewNormal, viewDir).xyz;
				vec3 specularColor = DFGTerm.z * (u_fresnel*DFGTerm.x + DFGTerm.y) * fTerm;//textureCube(u_tCube, viewNormal).xyz;


				vec3 brdf = (diffuse* u_diffuseColor * 2.0 + specularColor * 0.2) * NoL;
				// vec3 specColor = specularColor;/// + dirSpecular;
				// vec3 diffuseColor = u_diffuseColor * diffuse * u_lightColor;// + dirDiffuse;

				// gl_FragColor = vec4( diffuseColor + specColor + u_ambientColor * u_diffuseColor, 1.0);

				gl_FragColor = vec4(brdf * u_lightColor + u_ambientColor * u_diffuseColor, 1.0);
			}
		</script>
		<script type="text/javascript" src="./main.js"></script>

	</body>
</html>
